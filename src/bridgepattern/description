It allows you to vary not only your implementations but also abstractions.

There are 2 parts in Bridge design pattern :

-> Abstraction
-> Implementation
This is a design mechanism that encapsulates an implementation class inside of an interface class.

-> The bridge pattern allows the Abstraction and the Implementation to be developed independently
and the client code can access only the Abstraction part without being concerned about the Implementation part.

-> The abstraction is an interface or abstract class and the implementor is also an interface or abstract class.

-> The abstraction contains a reference to the implementor.
Children of the abstraction are referred to as refined abstractions,
and children of the implementor are concrete implementors.

-> Since we can change the reference to the implementor in the abstraction, we are able to change the abstraction’s
implementor at run-time. Changes to the implementor do not affect client code.
It increases the loose coupling between class abstraction and it’s implementation.

The UML class diagram for the Strategy pattern is the same as the diagram for the Bridge pattern.
However, these two design patterns aren't the same in their intent. While the Strategy pattern is meant for behavior,
the Bridge pattern is meant for structure.

The coupling between the context and the strategies is tighter than the coupling between the abstraction and the
implementation in the Bridge pattern.

As I understand it, you're using the strategy pattern when you're abstracting behavior that could be provided from
an external source (eg. config could specify to load some plugin assembly), and you're using the bridge pattern when
you use the same constructs to make your code a bit neater.
The actual code will look very similar - you're just applying the patterns for slightly different reasons.